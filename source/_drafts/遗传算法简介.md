---
title: '遗传算法简介'
date: 2018-03-11 14:18:05
tags: [Algorithm]
---

​	遗传算法借鉴了达尔文的进化论，是一种解决最优化的搜索算法

<div align=center>![](http://res.cloudinary.com/du3fbbzfy/image/upload/v1520750782/Genetic_Algorithm2.png>)</div>



## 具体步骤

**初始化 (initialization)**

先初始化一堆染色体，也就是一组编码，常见的编码方式有二进制、浮点数编码

**适应度函数 (evaluation)**

根据要达成的目标进行一个适应度排序（比如求要求一个函数的最小值，那么染色体所代表的数据越小，适应度越高），适应度决定了下一个阶段--选择中它们被使用的概率

**选择 (selection)**

一种比较常见的选择方法是使用轮盘选择法，根据适应度算出每条染色体在轮盘上所占的面积（百分比），根据这个比例随机选取要操作的两个亲本染色体

<!--more-->

**交叉 (crossover)**

两个染色体各选取长度相等的一部分进行交换，得到两个新的染色体，当然交叉的发生是有一定概率的，这个概率是可以设置的

**变异 (mutation)**

一条染色体的某一位发生变异，如0->1或1->0，变异的概率也是可以设置的

**迭代**

对新生成的染色体和原有的染色体进行适应度评估，并剔除适应度较小的染色体，如果不符合终止条件，则跳转至步骤（3），（这里的终止条件可以是达到了预定的遗传次数， 也可以是适应度达到了要求）

<div align=center>

![](http://res.cloudinary.com/du3fbbzfy/image/upload/v1520750782/Genetic_Algorithm1.png)

</div>



## 应用

这里给出一个简单的应用：用遗传算法求解一元函数的最小值（最大值改一下就可以），用到了Matlab中的Sheffield工具箱

```matlab
%遗传算法求y = sin(10*pi*x)/x在【1,2】内的最小值
clc
clear all
close all
%画图
figure(1);
hold on;
lb = 1;
ub = 2;
ezplot('sin(10*pi*X)/X',[lb,ub]);
xlabel('自变量/X')
ylabel('函数值/Y')
%定义遗传算法参数
NIND = 40;          %种群大小
MAXGEN  = 20;   %最大遗传代数
PRECI = 20;         %个体长度
GGAP = 0.95;        %代沟
px = 0.7;               %交叉概率
pm = 0.01;          %变异概率
trace = zeros(2,MAXGEN);    %寻优结果的初值
FieldD = [PRECI;lb;ub;1;0;1;1];     %区域描述器
Chrom = crtbp(NIND,PRECI);      %创建任意离散随机种群
%优化
gen = 0;                %代计数器
X = bs2rv(Chrom,FieldD);    %初始种群二进制到十进制的转换
ObjV = sin(10*pi*X)./X;     %计算目标函数值
while gen<MAXGEN
    FitnV = ranking(ObjV);      %分配适应度值
    SelCh = select('sus',Chrom,FitnV,GGAP);  %选择
    SelCh = recombin('xovsp',SelCh,px);     %交叉
    SelCh = mut(SelCh,pm);      %变异
    X = bs2rv(SelCh,FieldD);    %子代个体的十进制转换
    ObjVSel = sin(10*pi*X)./X;      %计算子代的目标函数值
    [Chrom, ObjV] = reins(Chrom,SelCh,1,1,ObjV,ObjVSel);    %重插入子代到父代，得到新种群
    X = bs2rv(Chrom,FieldD);
    gen = gen + 1;
    %获取每代的最优解及其序号，Y为最优解，I为个体的序号
    [Y,I] = min(ObjV);
    trace(1,gen) = X(I);        %记下每代的最优值
    trace(2,gen) = Y;            %记下每代的最优值
end
plot(trace(1,:),trace(2,:),'bo');   %画出每代的最优点
grid on;
plot(X,ObjV,'b*');      %画出最后一代的种群
hold off
%画进化图
figure(2);
plot(1:MAXGEN,trace(2,:));
grid on
xlabel('遗传代数')
ylabel('解的变化')
title('进化过程')
bestY = trace(2,end);
bestX = trace(1,end);
fprintf(['最优解：\nX = ',num2str(bestX),'\nY = ',num2str(bestY),'\n'])
```

**Result**

O表示每一代最优解，*表示最后一代的种群，由于函数比较简单，O很快就找到了最优解

<div align=center>![](http://res.cloudinary.com/du3fbbzfy/image/upload/v1520750782/Genetic_Algorithm3.png)</div>

可以看到随着遗传代数的增加，解开始收敛于一个稳定的值

<div align=center>![](http://res.cloudinary.com/du3fbbzfy/image/upload/v1520750782/Genetic_Algorithm4.png)</div>