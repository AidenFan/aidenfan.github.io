---
title: 深度学习中常用的优化算法
tags: Deep Learning
abbrlink: 6d62d50e
date: 2018-03-20 21:58:09
---

　　因为在求解最优化问题的时候有可能陷入局部最优或马鞍点（尤其当解处在一个高维空间中时）， Momentum, AdaGrad, RMSProp, Adam是解决这个问题的不同方法



## Momentum

　　类似于物理中惯性的概念，一个球从斜坡上滚下到达平面时由于惯性的作用会继续运动一段距离，当解处在局部最优或马鞍点时也引入这样一个概念，让它继续运动

　　式子如下，velocity考虑了之前所有的梯度和当前梯度的影响，由于衰减率的存在，越接近当前状态的梯度所占的权重越大，反之越小，这样就做到了让之前的状态影响现在的状态

![](https://gitee.com/zhili123/images/raw/master/MARA1.png)![](https://gitee.com/zhili123/images/raw/master/MARA2.png)

<!--more-->

## Nesterov Momentum

　　Nesterov Momentum与Momentum稍有不同换元之后比较好解释，首先计算了当前的velocity，然后用gradient对其进行校正，相当于对gradient进行了一些修正，有点类似于改进欧拉法

![](https://gitee.com/zhili123/images/raw/master/MARA3.png)![](https://gitee.com/zhili123/images/raw/master/MARA4.png)



## AdaGrad

```python
grad_squared = 0
while True:
    dx = compute_gradient(x)
    grad_squared += dx * dx
    x -= learning_rate * dx / (np.sqrt(grad_squared) + 1e-7)
    # 1e-7 是为了防止分母为零报错
```

　　考虑在不同维度的gradient

　　当dx很小时，dx除以一个很小的数，gradient变大

　　当dx很大时，dx除以一个很大的数，gradient变小

​	总体来说，循环次数越多，sqrt(grad_squared)越大，在凸优化中gradien可以帮助解稳定在最优附近，但在非凸优化中这可能导致解停在马鞍点，为了克服这个问题，在AdaGrad的基础之上稍作修改得到了RMSProp



## RMSProp

​	通过引入decay_rate避免梯度的累计导致的问题

​	这里的decay_rate可以设置为如0.9,0.99

```python
grad_squared = 0
while True:
    dx = compute_gradient(x)
    grad_squared += decay_rate * grad_squared + (1 - decay_rate) * dx * dx
    x -= learning_rate * dx / (np.sqrt(grad_squared) + 1e-7)
    # 1e-7 是为了防止分母为零报错
```

![](https://gitee.com/zhili123/images/raw/master/MARA5.png)

　　这是一张使用SGD在二维空间求解最优化问题的图，可以看到在纵向上有很多不必要的上下振荡，而在横向上的训练速度过慢 , 通过以上算法可以有效优化训练过程

​	Momentum ：gradient在纵向上正负叠加抵消，避免了不必要的振荡，在横向上累加，速度加快

​	AdaGrad/RMSProp：gradient在纵向被减小，在横向上被放大



## Adam 

　　Adam是Momentum和RMSProp的组合

```python
first_moment = 0
second_moment = 0
while True:
    dx = compute_gradient(x)
    first_moment = beta1 * first_moment + (1 - beta) * dx    # Momentum
    second_moment = beta2 * second_moment + (1 - beta2) * dx * dx
    x -= learning_rate * first_moment / (np.sqrt(second_moment) + 1e-7))    # AdaGrad/RMSProp
```

​	但是它的初始版本存在一个问题，第一步时，我们把first_moment和second_moment初始化为两个接近于0的数，计算出的x有可能非常大，这样结果就难以收敛，所以加入了Bias correction来避免最开始的几次循环可能出现的问题，当循环次数t越来越大时，（1 - beta**t)就越接近1，Bias correction的影响也就慢慢变小

```python
first_moment = 0
second_moment = 0
for t in range(num_iterations):
    dx = compute_gradient(x)
    first_moment = beta1 * first_moment + (1 - beta) * dx    # Momentum
    second_moment = beta2 * second_moment + (1 - beta2) * dx * dx

    # Bias correction
    first_unbias = first_moment / (1 - beta ** t)
    second_unbias = second_moment / (1 - beta2 ** t)

    x -= learning_rate * first_moment / (np.sqrt(second_moment) + 1e-7))    # AdaGrad/RMSProp
```

> ​	Adam with beta1 = 0.9, beta2 = 0.999, and learning_rate = 1e-3 or 5e-4 is a great starting point for many models!                                                                                                                                                             		  --Justin Johnson的经验之谈



## Reference

CS231n

